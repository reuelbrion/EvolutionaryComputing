//function 1 score:  	
//function 2 score:		
//function 3 score:		

import org.vu.contest.ContestSubmission;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.xy.XYDataset;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.jfree.ui.ApplicationFrame;
import org.vu.contest.ContestEvaluation;

import java.awt.Color;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;
import java.util.Properties;

public class player17 extends ApplicationFrame implements ContestSubmission 
{
	final static int POPULATION_SIZE = 100; //individuals
	final static int NUMBER_OF_POPULATIONS = 10;
	final static int PARENTS_SURVIVE = 20; //number of parents that survive into the next generation
	final static int NUMBER_OF_MUTATIONS = 1;
	final static boolean ONLY_MUTANTS = false; //wel of niet alleen mutanten als kinderen toeveogen aan nieuwe gen
	final static int RANDOM_MUTATION_CHANCE = 5; //procent kans dat een gen totaal random muteert
	
	ArrayList<Individual> population;
	private Random rnd_;
	private ContestEvaluation evaluation_;
	private int evaluations_limit_;
	JFreeChart chart;
	XYSeriesCollection dataset;
	int row;
	int column;
	
	
	public player17(String in)
	{
		super(in);
		rnd_ = new Random();
		population = new ArrayList<Individual>();
		dataset = new XYSeriesCollection();
		column = 0;
	}

	public void setSeed(long seed)
	{
		// Set seed of algortihms random process
		rnd_.setSeed(seed);
	}

	public void setEvaluation(ContestEvaluation evaluation)
	{
		// Set evaluation problem used in the run
		evaluation_ = evaluation;

		// Get evaluation properties
		Properties props = evaluation.getProperties();
		evaluations_limit_ = Integer.parseInt(props.getProperty("Evaluations"));
		boolean isMultimodal = Boolean.parseBoolean(props.getProperty("Multimodal"));
		boolean hasStructure = Boolean.parseBoolean(props.getProperty("GlobalStructure"));
		boolean isSeparable = Boolean.parseBoolean(props.getProperty("Separable"));
		
		// Change settings(?)
		if(isMultimodal){
			// Do sth
		}else{
			// Do sth else
		}
	}

	public void run()
	{
		// Run your algorithm here
		//set random values for starting array
		int evals = 1;
		initPopulation(); 
		
		while(evals<evaluations_limit_/POPULATION_SIZE)
		{
			makeNewPopulation();
			Iterator<Individual> iterator = population.iterator();
			XYSeries series = new XYSeries("column");
			while(iterator.hasNext())
			{
				double fitness = iterator.next().fitness.doubleValue();
				series.add(column, fitness);
			}
			column++;
			row++;
			dataset.addSeries(series);
			//System.out.println("best fitness: " + population.get(0).fitness + " worst fitness:  " + population.get(99).fitness + " evals: " + evals);
			evals++;
		}

		//maak een plot op scherm
		chart = ChartFactory.createScatterPlot(
	            "Line Chart 1",       // chart title
	            "Evals",                    // domain axis label
	            "Fitness",                   // range axis label
	            dataset,                   // data
	            PlotOrientation.VERTICAL,  // orientation
	            true,                      // include legend
	            true,                      // tooltips
	            false                      // urls
	        );
		chart.setBackgroundPaint(Color.white);
		final CategoryPlot plot = (CategoryPlot) chart.getPlot();
	    plot.setBackgroundPaint(Color.lightGray);
	    plot.setRangeGridlinePaint(Color.white);
	    final ChartPanel chartPanel = new ChartPanel(chart);
        chartPanel.setSize(500, 700);
        setContentPane(chartPanel);
        this.setVisible(true);
	}
	
	void makeNewPopulation()
	{
		Random rand = new Random();
		ArrayList<Individual> tempPopulation = new ArrayList<Individual>();
		for(int i = 0; i < PARENTS_SURVIVE; i++)
		{
			tempPopulation.add(i, population.get(i));
		}
		while(tempPopulation.size() < POPULATION_SIZE)
		{			
			Individual parent1 = population.get(rand.nextInt(PARENTS_SURVIVE));
			Individual parent2 = population.get(rand.nextInt(PARENTS_SURVIVE));
			Individual child = crossoverParents(parent1, parent2);
			if(!ONLY_MUTANTS)
			{
				child.fitness = (Double)evaluation_.evaluate(child.genome);
				addToPopulationSorted(child, tempPopulation);
			}
			Individual mutant = child.clone();
			mutateChild(mutant);
			mutant.fitness = (Double)evaluation_.evaluate(mutant.genome);
			addToPopulationSorted(mutant, tempPopulation);
		}
		population = tempPopulation;
	}
	
	private Individual crossoverParents(Individual parent1, Individual parent2)
	{
		Random rand = new Random();
		Individual child = new Individual();
		for(int i = 0; i < parent1.genome.length; i++)
		{
			if (rand.nextBoolean())
			{
				child.genome[i] = parent1.genome[i];
			}
			else
			{
				child.genome[i] = parent2.genome[i];
			}
		}
		return child;
	}
	
	private void mutateChild(Individual child)
	{
		Random rand = new Random();
		int[] mutatePosition = createMutatePositionsArray(NUMBER_OF_MUTATIONS);	
		for (int i = 0; i < NUMBER_OF_MUTATIONS; i++)
		{
			double oldValue = child.genome[mutatePosition[i]];
			double mutation = rand.nextDouble();
			if(rand.nextBoolean())
			{
				mutation *= -1d;
			}
			mutation = oldValue + mutation;
			if(mutation > 5d)
			{
				mutation = 5d;
			}
			else if(mutation < -5d)
			{
				mutation = -5d;
			}
			child.genome[mutatePosition[i]] = mutation;
			//small change of totaly random mutation
			if(rand.nextInt(100) < RANDOM_MUTATION_CHANCE)
			{
				child.genome[mutatePosition[i]] = ((rand.nextDouble() * 10d) - 5d);
			}
		}
	}

	private int[] createMutatePositionsArray(int size) 
	{
		Random rand = new Random();
		int[] output = new int[size];
		output[0] = rand.nextInt(10);
		for (int i = 1; i<size; i++)
		{
			int newPosition = rand.nextInt(10);
			while(arrayContains(output, newPosition, i))
			{
				newPosition = rand.nextInt(10);
			}
			output[i] = newPosition;
		}
		return output;
	}

	private boolean arrayContains(int[] intArray, int check, int steps) 
	{
		for (int i = 0; i < steps; i++)
		{
			if (intArray[i] == check)
			{
				return true;
			}
		}
		return false;
	}

	public void addToPopulationSorted(Individual input, ArrayList<Individual> pop)
	{
		int index = 0;
		while(index < pop.size() && population.get(index).fitness > input.fitness)
		{
			index++;
		}
		pop.add(index, input);
	}
	
	public void initPopulation()
	{
		Individual ind = new Individual();
		ind.initializeRandom();
		ind.fitness = (Double)evaluation_.evaluate(ind.genome);
		population.add(ind);
		while(population.size() < POPULATION_SIZE)
		{
			ind = new Individual();
			ind.initializeRandom();
			ind.fitness = (Double)evaluation_.evaluate(ind.genome);
			addToPopulationSorted(ind, population);
		}
	}
}

