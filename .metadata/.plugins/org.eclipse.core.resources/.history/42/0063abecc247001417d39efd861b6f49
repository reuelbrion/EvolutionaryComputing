

import org.vu.contest.ContestSubmission;
import org.vu.contest.ContestEvaluation;

import java.util.Random;
import java.util.Properties;
//test
public class CopyOfplayer17 implements ContestSubmission
{
	final static int POPULATION_SIZE = 2;
	
	private Random rnd_;
	private ContestEvaluation evaluation_;
	private int evaluations_limit_;

	private double[] currentScore;
	
	public CopyOfplayer17()
	{
		rnd_ = new Random();
		currentScore = new double[2];
	}

	public void setSeed(long seed)
	{
		// Set seed of algortihms random process
		rnd_.setSeed(seed);
	}

	public void setEvaluation(ContestEvaluation evaluation)
	{
		// Set evaluation problem used in the run
		evaluation_ = evaluation;

		// Get evaluation properties
		Properties props = evaluation.getProperties();
		evaluations_limit_ = Integer.parseInt(props.getProperty("Evaluations"));
		boolean isMultimodal = Boolean.parseBoolean(props.getProperty("Multimodal"));
		boolean hasStructure = Boolean.parseBoolean(props.getProperty("GlobalStructure"));
		boolean isSeparable = Boolean.parseBoolean(props.getProperty("Separable"));

		// Change settings(?)
		if(isMultimodal){
			// Do sth
		}else{
			// Do sth else
		}
	}

	public void run()
	{
		// Run your algorithm here

		int evals = 0;
		
		//set random values for starting array
		double[][] population = initPopulation(); 
		
		while(evals<evaluations_limit_/population.length)
		{
			// Select parents
			int[] bestParents = {0,1};
			Double[] parentFitness = {(Double)evaluation_.evaluate(population[0]), (Double)evaluation_.evaluate(population[1])};
			Double currentFitness;
			for (int i = 2; i < population.length; i++)
			{
				currentFitness = (Double)evaluation_.evaluate(population[i]);
				if(currentFitness > parentFitness[0])
				{
					if(parentFitness[0] > parentFitness[1])
					{
						bestParents[1] = i;
						parentFitness[1] = currentFitness;
					}
					else
					{
						bestParents[0] = i;
						parentFitness[0] = currentFitness;
					}
				
				}
				else if(currentFitness  > parentFitness[1])
				{
					bestParents[1] = i;
					parentFitness[1] = currentFitness;
				}
			}	
			
			System.out.println("p1 fitness: " + parentFitness[0] + " p2 fitness:  " + parentFitness[1] + " evals: " + evals);
			currentScore[0] = parentFitness[0];
			currentScore[1] = parentFitness[1];
			population = createPopulationFromParents(population[bestParents[0]], population[bestParents[1]]);
			
			evals++;
		}
	}
	
	private void crossoverParents(double[] parent1, double[] parent2)
	{
		int maxNumberOfCrossoverPoints = 2; //might want to try different values
		Random rand = new Random();
		int base = 0;
		boolean flip = true;
		for(int i = 0; i<maxNumberOfCrossoverPoints; i++)
		{
			int nextCrossoverPoint = rand.nextInt(10-base)+base;
			if(nextCrossoverPoint >= parent1.length)
			{
				break;
			}
			if (flip)
			{
				for(int j = base; j<nextCrossoverPoint; j++)
				{
					double temp = parent1[j];
					parent1[j] = parent2[j];
					parent2[j] = temp;
				}
				flip = !flip;
			}
			else
			{
				flip = !flip;
			}
			
			base = nextCrossoverPoint;
		}
	}
	
	private double[][] createPopulationFromParents(double[] parent1, double[] parent2) 
	{
		double[][] output = new double[10][POPULATION_SIZE];		
		for (int i = 0; i < output.length; i+=2)
		{
			double[] child1 = parent1.clone();
			double[] child2 = parent2.clone();
			crossoverParents(child1, child2);
			output[i] = mutateChild(child1);
			output[i+1] = mutateChild(child2);
		}		
		return output;
	}

	private double[] mutateChild(double[] child)
	{
		int numberOfMutations = 3;
		double currentScoreDub = currentScore[0] + currentScore[1];
		if (currentScoreDub > 2d && currentScoreDub <= 10d)
		{
			numberOfMutations = 2;
		}
		else if (currentScoreDub > 10d)
		{
			numberOfMutations = 1;
		}
		Random rand = new Random();
		int[] mutatePosition = createMutatePositionsArray(numberOfMutations);	
		for (int i = 0; i < numberOfMutations; i++)
		{
			child[mutatePosition[i]] = ((rand.nextDouble() * 10d) - 5d);
		}
		return child;
	}

	private int[] createMutatePositionsArray(int size) 
	{
		Random rand = new Random();
		int[] output = new int[size];
		output[0] = rand.nextInt(9);
		for (int i = 1; i<size; i++)
		{
			int newPosition = rand.nextInt(9);
			while(arrayContains(output, newPosition, i))
			{
				newPosition = rand.nextInt(9);
			}
			output[i] = newPosition;
		}
		return output;
	}

	private boolean arrayContains(int[] intArray, int check, int steps) 
	{
		for (int i = 0; i < steps; i++)
		{
			if (intArray[i] == check)
			{
				return true;
			}
		}
		return false;
	}

	public double[][] initPopulation()
	{
		double[][] output = new double[10][POPULATION_SIZE]; //proberen te varieren?
		for (int i = 0; i < output.length; i++)
		{
			output[i] = makeRandomDoubleArray();
		}		
		return output;
	}
	
	public double[] makeRandomDoubleArray()
	{
		double randDub;
		Random rand = new Random();
		double[] output = new double[10];
		for (int i = 0; i < output.length; i++)
		{
			randDub = rand.nextDouble();
			randDub *= 10d;
			randDub -= 5d;
			output[i] = randDub;
		}		
		
		return output;
	}
}

